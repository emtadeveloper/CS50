/*
--------------------------------------------------------------------------------------------------------------------------------------------------
==================================================================================================================================================

Concept Argoritm :مجموعه از مراحل برای حل یک مسله رو الگوریتم میگویند هربرنامه ای که توسعه داده می شود از یک یا چند الگوریتم

تشکیل شده است هدف اصلی خل مسایل با استفاده از الگوریتم ها است

انتخاب درست یک الگوریتم به منظور ارایه بهترین راه حل برای حل مسله مورد نظر امون هستش

بهترین راه حل مسله

۱- تعداد کد های کمتر که فرایند های پردازشی رو برامون کمتر میکنه و خوانایی کد بهتری رو هم داریم و در نتیجه سرعت بیشتری داره کدمون

۲- بیشتر استفاده از حافظه کمتر Performance  تمرکز اصلی ما روی 

مثال ما  اگر بخایم بیایم و یک الگوریتم بنویسیم برای جمع مقادیر داخل یک آرایه و بخایم میزان پیچیدگی اون رو اندازه بگیریم میتونیم بیایم
و به صورت زیر عمل بکنیم


function addNumbers(number){

      let  result = 0;  // run : 1

      for(const item of numbers){ // run : 1

        result += item  // run : n legth array

      }

      return result // run : 1
}

// T : 1 + 1 + 1 + n  = 3 + n

console.log(addNumbers([2,8,10,5]))


===================================================================================================================================================

برای مثال ما دو نوع  مدل الگوریتم برای سرچ زدن داخل یک آرایه داریم


۱- Binary Search : نیازی به مرتب سازی نداشتیم ولی در اینlinear در این هستش که ما در نوعBinary مهم ترین نوع این مدل سرچ با نوع سرچ به صورت
مدل باید بیایم و مرتب سازی رو هم انجام بدهیم ما اگر بخایم بیایم و از این روش  استفاده بکنیم بهتر هستش که بیایم و  آرایه یا المان هامون رو 
مرتب سازی بکنیم در این مدل کاری که ما انجام میدهیم این هستش که میایم و آرایه امون رو به دو قسمت تبدیل میکنیم و هر کدوم از قسمت هارو میایم 
و مرتب سازی میکنیم و بعد به جستجو امون ادامه میدهیم

رو داشته باشیم comparison یکی از حالت های خوب سرچ کردن به صورت باینری اینه اگر مثلا ۱ ملیون آیتم داشته باشیم حدودا ۱۹ بار فقط لازمه که بیایم و عمل 

function findElement(sortedArr, element) {
    let startIndex = 0
    let endIndex = sortedArr.length - 1

    const middleIndex = Math.floor((endIndex - startIndex) / 2)
    if (element == sortedArr[middleIndex]) {
        return middleIndex
    }
}

const number = [3, 5, 10, 22, 51]

console.log(findElement(number, 10))


۲- linear : پیمایش ارایه تا زمان رسیدن به المنت مورد نظر امون جلو میره و نیازی به مرتب سازی لیست برای جستجو نیست و میاد و از چپ به راست کل 
آرایه امون رو پیمایش میکنه

Complexing Time : O (n)   Ω (1)

function findElement(arr, element) {
    let index = 0;
    for (const item of arr) {
        if (item === element) {
            return index
        }
        index++
    }
}

const number = [5, 3, 10, 51, 22]
console.log(findElement(number, 3))
 


===================================================================================================================================================

Big (O) notation :  سرعت اجرای یک برنامه رو بررسی میکنه که یک الگوریتم چقدر میتونه زمان بر باشه تا بیاد و اجرا بشه وقتی حجم اون داده های ورودی
هستش linear زیاد میشه این الگوریتم چطوری رفتار میکنه و پرفورمنس اش میاد و پایین و کند میشه و اصطلاحا میگویم که از نوع 

Big O (n ^ 2) QUARATIC :  هستش n به این صورت هستند که میاد ودو تا حلقه ی تو در تو که وابسته به تعداد

Big O ( log n ) LOGARITHMIC : بهترین نوع برای ما همین هستش که میتونیم بیایم و استفاده بکنیم 

Big (Ω) Notation : تعداد مراحل  یک الگوریتم  که میتونیم آن را بهترین مرحله یا حالت بیایم و بنامیم یا حداقل گام های لازم برای اجرای یک  الگوریتم

===================================================================================================================================================
 
انواع الگوریتم های مرتب سازی

۱- Selection Sort :  آرایه از اعداد رو میگیره و کوچک ترین آن هارو انتخاب میکنه و اون رو در ابتدای آرایه قرار میده و سبس در باقی مانده آرایه 
شروع میکنه به جسنجو و به همین شکل کوچک ترین هارو بیدا میکنه و مرتب سازی شون میکنه به تعداد خونه ها منهای یک میاد و عمل مقایسه رو انجام میده
و این کار برای این هستش که خونه آخر دیگه مقایسه شده و دیگه نیازی به مقایسه کردن اون نیستش

سرعت اجرا  O (n ^ 2 )

function selectionSort(arr) {

    for (let i = 0; i < arr.length; i++) {
        let minIndex = i;

        for (let j = i + 1; j < arr.length; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }

        if (i !== minIndex) {
            const lesser = arr[minIndex];
            arr[minIndex] = arr[i];
            arr[i] = lesser;
        }
    }

    return arr;
}

console.log(selectionSort([10, 4, 3, 8, -10]));

//output : [ 3, 4, 8, 10 ]


function sort(arr) {
    const resultArray = [...arr]
    for (let outer = 0; outer < resultArray.length; outer++) {
        let outerEl = resultArray[outer]
        for (let inner = outer + 1; inner < resultArray.length; inner++) {
            let innerEl = resultArray[inner]
            if (outerEl > innerEl) {
                resultArray[outer] = innerEl;
                resultArray[inner] = outerEl
                outerEl = resultArray[outer]
                innerEl = resultArray[inner]
            }
        }
    }
    return resultArray
}

const sortedArray = sort([2, 10, 6, 3, 21])

console.log(sortedArray)


2- Bubble Sort : در این روش میاد و آیتم های آرایه امون رو به صورت دوتایی مرتب میکنه و بر اساس اون ها مرتب سازی میکنه و این
عمل رو اینقد تکرار میکنه که دیگه  ترتیب ها درست برقرار بشن

سرعت اجرا  O (n ^ 2 )

function bubbleSort(arr) {
    //sort the array
    for (let i = 0; i < arr.length; i++) {
        for (let j = 0; j < arr.length - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                const lesser = arr[j + 1];
                arr[j + 1] = arr[j];
                arr[j] = lesser;
            }
        }
    }

    //returning the array
    return arr;
}

console.log(bubbleSort([10, 4, 3, 8]));
//output : [ 3, 4, 8, 10 ]


3- Merge Sort : در این روش با گرفتن یک آرایه و تقسیم اون به دو قسمت چب و راست و مرتب کردن هر کدوم از نیمه ها
شروع به کار می کند و بعد از مرتب سازی اون نیمه هارو میاد و باهم دیگه  ادغام میکند

function insertionSort(arr) {
    const len = arr.length;

    for (let i = 0; i < len; i++) {
        let key = arr[i];
        let j = i - 1;

        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }

        arr[j + 1] = key;
    }

    return arr;
}

console.log(insertionSort([20, 5, 15, 35, 10]));
//output: [ 5, 10, 15, 20, 35 ]


سرعت اجرا  O ( n log n )

===================================================================================================================================================
---------------------------------------------------------------------------------------------------------------------------------------------------
*/